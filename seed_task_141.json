[
    {
        "instruction": "سوال زیر از کوئرا را حل کن.",
        "input": "«تانوس» به‌ دنبال ۶ سنگ بی‌نهایت می‌گردد تا با آن‌ها بازی کند. (اگر فیلم‌های Avengers را دیده باشید کاملاً در جریان هستید.)\nهر کدام از این ۶ سنگ یک نام و یک رنگ دارند. سنگ فضا (space) به رنگ آبی (blue)، سنگ ذهن (mind) به رنگ زرد (yellow)، سنگ واقعیت (reality) به رنگ قرمز (red)، سنگ قدرت (power) به رنگ بنفش (purple)، سنگ زمان (time) به رنگ سبز (green) و سنگ روح (soul) به رنگ نارنجی (orange) است.\nاما «تانوس» کوررنگی دارد و از شما می‌خواهد که با دریافت نام هر سنگ، رنگ آن را به او بگویید.",
        "output": "کد زیر می تواند سوال بالا را حل کند:\n\n# Get name of stone from standart input\nstone = input()\n\n# Specify color of stone according to its name\nif stone == \"space\":\n    print(\"blue\")\nelif stone == \"mind\":\n    print(\"yellow\")\nelif stone == \"reality\":\n    print(\"red\")\nelif stone == \"power\":\n    print(\"purple\")\nelif stone == \"time\":\n    print(\"green\")\nelif stone == \"soul\":\n    print(\"orange\")\n\nدر کد بالا ابتدا نام سنگ به عنوان ورودی از کاربر گرفته شده و سپس به کمک دستورات شرطی رنگ سنگ با توجه به اسم آن در خروجی چاپ شده است."
    },
    {
        "instruction": "سوال زیر از Leetcode زا با الگوریتم حریصانه حل کن.",
        "input": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.",
        "output": "کد زیر سوال را با الگوریتم حریصانه و با پیچیدگی زمانی O(n) حل کرده است:\n\nclass Solution:\n    def maxArea(self, height: List[int]) -> int:\n        l, r = 0, len(height) - 1\n        ans = 0\n\n        for w in range(len(height) - 1, 0, -1):\n            if height[l] < height[r]:\n                ans = max(ans, height[l] * w)\n                l += 1\n            else:\n                ans = max(ans, height[r] * w)\n                r -= 1\n\n        return ans\n\nدر این راه حل ابتدا دو سر آرایه را به عنوان انتهای محفظه در نظر می‌گیریم و سپس اندیس آن را به سمت مرکز می‌بریم. اگر ارتفاع انتهایی که به سمت مرکز رفته‌ایم کمتر از ارتفاع انتهایی که به سمت مرکز نرفته‌ایم بود، آنگاه انتهایی که به سمت مرکز رفته‌ایم را به عنوان انتهای محفظه در نظر می‌گیریم و در غیر این صورت انتهایی که به سمت مرکز نرفته‌ایم را به عنوان انتهای محفظه در نظر می‌گیریم. این کار را تا زمانی ادامه می‌دهیم که اندیس انتهای محفظه‌ای که به سمت مرکز رفته‌ایم برابر اندیس انتهای محفظه‌ای که به سمت مرکز نرفته‌ایم شود. در این صورت محفظه‌ای که به دست آمده است، بزرگترین محفظه است."
    },
    {
        "instruction": "فقط کد سوال زیر را بنویس.",
        "input": "فرض کنید دو آرایه مرتب از اعداد صحیح داده شده باشد. لطفاً یک الگوریتم بنویسید که این دو آرایه را بگیرد و یک آرایه مرتب جدیدی را تولید کند که شامل تمام اعداد از هر دو آرایه باشد و نیز مرتب شده باشد.",
        "output": "def merge_sorted_arrays(arr1, arr2):\n    merged_array = []\n    i, j = 0, 0\n    \n    # Merge two arrays\n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] < arr2[j]:\n            merged_array.append(arr1[i])\n            i += 1\n        else:\n            merged_array.append(arr2[j])\n            j += 1\n    \n    merged_array.extend(arr1[i:])\n    merged_array.extend(arr2[j:])\n    \n    return merged_array\n\n# Examples\narr1 = [1, 3, 5, 7]\narr2 = [2, 4, 6, 8]\nresult = merge_sorted_arrays(arr1, arr2)\nprint(\"Merged arrays: \", result)"
    },
    {
        "instruction": "الگوریتم زیر را توضیح بده.",
        "input": "حریصانه",
        "output": "الگوریتم‌های حریصانه یک روش حل مسائل بهینه‌سازی هستند که در هر مرحله از مسئله بهترین انتخاب ممکن را می‌کنند، بدون آن‌که به طریق کلی بهینه‌سازی کنند. این الگوریتم‌ها معمولاً برای مسائلی که به سادگی قابل تجزیه به زیرمسائل کوچک‌تر نیستند و از ماهیت گردآوری‌ای (Greedy) برخوردار هستند، موثر هستند.\nدر هر مرحله از اجرای الگوریتم حریصانه، تصمیمی گرفته می‌شود که در آن لحظه بهترین نتیجه ممکن را فراهم می‌کند، بدون توجه به تصمیم‌های آینده و اثرات آنها. این بدان معناست که الگوریتم‌های حریصانه تصمیمات محلی را انتخاب می‌کنند که ممکن است منجر به بهینه‌سازی یا بهبود کلی نشوند.\nالگوریتم حریصانه عموماً سرعت اجرای بالا و پیاده‌سازی ساده‌ای دارند، اما ممکن است به نتایج زیر بهینه یا حتی غیر قابل قبول منجر شوند. بنابراین، برای استفاده از الگوریتم‌های حریصانه، مهم است که مسئله مورد نظر به وضوح تعریف شده و شرایطی که الگوریتم ممکن است به عنوان بهینه تصاحب کند، مشخص باشند."
    },
    {
        "instruction": "سوال زیر را به کمک برنامه نویسی بازگشتی حل کن.",
        "input": "عدد فیبوناچی i ام را حساب کنید.",
        "output": "def fib(i):\n    if i == 0:\n        return 0\n    elif i == 1:\n        return 1\n    else:\n        return fib(i-1) + fib(i-2)\n\nدر این روش شرط خاتمه یکی از شرط های پایه است. اگر i برابر 0 یا 1 باشد، مقدار 0 یا 1 برگردانده می شود. در غیر این صورت، مقدار فیبوناچی i ام با استفاده از دو فراخوانی بازگشتی محاسبه می شود."
    },
    {
        "instruction": "الگوریتم زیر را توضیح بده",
        "input": "Bubble Sort",
        "output": "در این الگوریتم ابتدا از ابتدا لیست را چک میکنیم و اگر عنصر اول از عنصر دوم بزرگتر بود جاهای آنها را عوض میکنیم و همین کار را برای همه عناصر انجام میدهیم تا به جایگاه درستی برسند."
    },
    {
        "instruction": "دو الگوریتم زیر را از نظر پیچیدگی زمانی مقایسه کن.",
        "input": "Bubble Sort Algorithm, Merge Sort Algorithm",
        "output": "پیچیدگی زمانی الگوریتم مرتب سازی حبابی O(n^2) و الگوریتم مرتب سازی ادغامی O(nlogn) است."
    },
    {
        "instruction": "الگوریتم زیرا را توضیح بده و کد آن را بنویس.",
        "input": "DFS",
        "output": "الگوریتم DFS یک الگوریتم جستجو در گراف است که از روشی بازگشتی برای کاوش گراف استفاده می‌کند. DFS مخفف عبارت Depth-First Search است که به معنای جستجوی عمقی می‌باشد. در این الگوریتم، از اولویت دادن به تکرارهای عمقی به جای تعداد گره‌های مجاور استفاده می‌شود.\nالگوریتم DFS به این شکل عمل می‌کند:\n۱- از یک گره شروع می‌کند و آن را به عنوان گره فعلی انتخاب می‌کند.\n۲- برای هر گره مجاوری که هنوز بازدید نشده باشد، DFS را با آن گره به عنوان گره فعلی فراخوانی می‌کند.\n۳- این عملیات تکرار می‌شود تا زمانی که دیگر گره بازدید نشده ای وجود نداشته باشد.\nکد زیر نمونه از پیاده سازی الگوریتم DFS را نشان می دهد:\ndef dfs(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    print(start)  # Print or process the current node\n    \n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n\n# Examples:\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['A', 'D', 'E'],\n    'C': ['A', 'F'],\n    'D': ['B'],\n    'E': ['B', 'F'],\n    'F': ['C', 'E']\n}\n\nprint(\"Result of DFS:\")\ndfs(graph, 'A')"
    },
    {
        "instruction": "مسئله زیر را توضیح بده و تفاوت آن را را مسائل NP-hard بگو.",
        "input": "NPC",
        "output": "تعریف: یک مسئله NP-complete هم در کلاس NP است و هم NP-hard. به عبارت دیگر، برای یک مسئله NPC، نه تنها تمام مسائل NP به سرعت به آن تبدیل می‌شوند، بلکه خود مسئله نیز باید در زمان چندجمله‌ای قابل بررسی باشد.\nمثال‌ها: مسئله 3-SAT، مسئله کوله‌پشتی، مسئله رنگ‌آمیزی گراف.\nمشخصه کلیدی: همه مسائل NPC به طور خودکار NP-hard هستند، اما برعکس آن صدق نمی‌کند. یعنی هر مسئله NP-hard لزوماً NPC نیست.\n\nتفاوت اصلی:\nتفاوت اصلی بین NP-hard و NPC در این است که مسائل NP-complete حتماً باید جزء کلاس NP باشند، در حالی که مسائل NP-hard ممکن است خارج از این کلاس قرار داشته باشند. به عبارت دیگر، تمام مسائل NPC NP-hard هستند، اما همه مسائل NP-hard لزوماً NPC نیستند."
    },
    {
        "instruction": "سوال زیر از Leetcode را به کمک زبان پایتون حل کن. سپس راه حلت را توضیح بده.",
        "input": "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
        "output": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef remove_nth_from_end(head: ListNode, n: int) -> ListNode:\n    # Initialize dummy node\n    dummy = ListNode(0)\n    dummy.next = head\n    fast = slow = dummy\n    \n    # Move fast ahead by n+1 steps\n    for _ in range(n+1):\n        fast = fast.next\n        \n    # Move fast to the end, maintaining the gap\n    while fast:\n        fast = fast.next\n        slow = slow.next\n        \n    # Skip the desired node\n    slow.next = slow.next.next\n    return dummy.next\n\n# Helper function to print the list (for demonstration purposes)\ndef print_list(head):\n    while head:\n        print(head.val, end=\" -> \" if head.next else \"\\n\")\n        head = head.next\n\n# Testing the function with a sample list\nhead = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\nn = 2\nnew_head = remove_nth_from_end(head, n)\nprint_list(new_head)  # Expected output: 1 -> 2 -> 3 -> 5\n\nبرای حل این مسئله، ما از روش دو اشاره‌گر استفاده خواهیم کرد. در این روش، دو اشاره‌گر داریم: fast و slow. اشاره‌گر fast ابتدا n گام جلوتر از slow حرکت می‌کند. سپس هر دو اشاره‌گر با هم حرکت می‌کنند تا زمانی که fast به انتهای لیست برسد. در این زمان، slow به گره‌ای اشاره می‌کند که باید حذف شود."
    },
    {
        "instruction": "یک پیاده سازی از الگوریتم زیر برای یافتن کوتاه ترین مسیر ارائه بده.",
        "input": "A*",
        "output": "import heapq\n\nclass Node:\n    \"\"\"A node class for A* Pathfinding\"\"\"\n\n    def __init__(self, parent=None, position=None):\n        self.parent = parent\n        self.position = position\n        self.g = 0\n        self.h = 0\n        self.f = 0\n\n    def __eq__(self, other):\n        return self.position == other.position\n\n    def __lt__(self, other):\n        return self.f < other.f\n\ndef astar(maze, start, end):\n    \"\"\"Returns a list of tuples as a path from the given start to the given end in the given maze\"\"\"\n\n    # Create start and end node\n    start_node = Node(None, start)\n    start_node.g = start_node.h = start_node.f = 0\n    end_node = Node(None, end)\n    end_node.g = end_node.h = end_node.f = 0\n\n    # Initialize both open and closed list\n    open_list = []\n    closed_list = []\n\n    # Add the start node\n    heapq.heappush(open_list, start_node)\n\n    # Loop until you find the end\n    while len(open_list) > 0:\n\n        # Get the current node\n        current_node = heapq.heappop(open_list)\n        closed_list.append(current_node)\n\n        # Found the goal\n        if current_node == end_node:\n            path = []\n            current = current_node\n            while current is not None:\n                path.append(current.position)\n                current = current.parent\n            return path[::-1]  # Return reversed path\n\n        # Generate children\n        children = []\n        for new_position in [(0, -1), (0, 1), (-1, 0), (1, 0)]:  # Adjacent squares\n\n            # Get node position\n            node_position = (current_node.position[0] + new_position[0], current_node.position[1] + new_position[1])\n\n            # Make sure within range\n            if node_position[0] > (len(maze) - 1) or node_position[0] < 0 or node_position[1] > (len(maze[len(maze)-1]) - 1) or node_position[1] < 0:\n                continue\n\n            # Make sure walkable terrain\n            if maze[node_position[0]][node_position[1]] != 0:\n                continue\n\n            # Create new node\n            new_node = Node(current_node, node_position)\n\n            # Append\n            children.append(new_node)\n\n        # Loop through children\n        for child in children:\n\n            # Child is on the closed list\n            if child in closed_list:\n                continue\n\n            # Create the f, g, and h values\n            child.g = current_node.g + 1\n            child.h = abs(child.position[0] - end_node.position[0]) + abs(child.position[1] - end_node.position[1])\n            child.f = child.g + child.h\n\n            # Child is already in the open list\n            if any(open_node for open_node in open_list if child == open_node and child.g > open_node.g):\n                continue\n\n            # Add the child to the open list\n            heapq.heappush(open_list, child)\n\n    return None\n\n# A sample maze (2D grid), where 1 represents obstacles and 0 represents free path\nmaze = [\n    [0, 0, 0, 0, 0, 0],\n    [0, 1, 1, 1, 1, 0],\n    [0, 0, 0, 0, 0, 0],\n    [0, 1, 1, 1, 1, 0],\n    [0, 0, 0, 0, 0, 0]\n]\n\nstart = (0, 0)  # Starting position\nend = (4, 5)    # Ending position\n\npath = astar(maze, start, end)\npath\n\nالگوریتم A* (اِی‌استار) یک الگوریتم جستجوی گراف است که برای یافتن کوتاه‌ترین مسیر بین دو گره (نقطه شروع و نقطه پایان) استفاده می‌شود. این الگوریتم از یک تابع هزینه برای ارزیابی کیفیت مسیرهای ممکن استفاده می‌کند که ترکیبی از دو جزء است:\ng(n): هزینه مسیر از نقطه شروع تا گره n.\nh(n): یک تخمین هزینه برای رسیدن از گره n به گره هدف.\nتابع هزینه کلی f(n) برای هر گره n به صورت زیر است:\nf(n)=g(n)+h(n)"
    },
    {
        "instruction": "برای سوال  زیر از Leetcode ابتدا کد را به زبان c بنویس سپس کد خود را به صورت بسیار \nمختصر توضیح بده.",
        "input": "Merge k Sorted Lists",
        "output": "#include <stdio.h>\n#include <stdlib.h>\n\n// تعریف ساختار برای یک گره\nstruct ListNode {\n    int val;\n    struct ListNode *next;\n};\n\nstruct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2){\n    if (l1 == NULL) return l2;\n    if (l2 == NULL) return l1;\n    \n    if (l1->val < l2->val) {\n        l1->next = mergeTwoLists(l1->next, l2);\n        return l1;\n    } else {\n        l2->next = mergeTwoLists(l1, l2->next);\n        return l2;\n    }\n}\n\nstruct ListNode* mergeKLists(struct ListNode** lists, int listsSize) {\n    if (listsSize == 0) return NULL;\n    if (listsSize == 1) return lists[0];\n    \n    // ادغام دو به دوی لیست‌ها\n    while (listsSize > 1) {\n        for (int i = 0; i < listsSize / 2; i++) {\n            lists[i] = mergeTwoLists(lists[i], lists[i + listsSize / 2]);\n        }\n        listsSize = (listsSize + 1) / 2;\n    }\n    \n    return lists[0];\n}\n\nتابع mergeTwoLists: این تابع دو لیست مرتب‌شده را می‌گیرد و آن‌ها را به صورت بازگشتی با هم ادغام می‌کند.\nتابع mergeKLists: این تابع لیستی از لیست‌ها و اندازه آن را می‌گیرد. ابتدا شرایط پایه را بررسی می‌کند (مثلا اگر تعداد لیست‌ها صفر یا یک باشد). سپس، با استفاده از تابع mergeTwoLists، دو به دوی لیست‌ها را با هم ادغام می‌کند تا در نهایت یک لیست مرتب‌شده باقی بماند. این فرآیند به صورت تکراری ادامه می‌یابد تا تمام لیست‌ها ادغام شوند."
    },
    {
        "instruction": "مسئله زیر را حل کن و روش حل را با جزئیات توضیح بده.",
        "input": "در یک واگن مترو دو ردیف صندلی روبروی هم داریم که هر ردیف شامل ۸ صندلی است. هر صندلی یا خالی است و یا کسی روی آن نشسته.\n\nمی‌دانیم اگر کسی روی صندلی شماره i نشسته باشد فقط به روبروی خود، یعنی صندلی شماره i ردیف مقابل نگاه می‌کند و اگر شخصی روی آن صندلی نشسته باشد باهم «چشم تو چشم» می‌شوند.\n\nبه شما وضعیت نشستن افراد داده می‌شود و از شما تعداد جفت‌های چشم تو چشم در یک واگن را می‌خوایم.\n\nورودی\nورودی در دو سطر و در هر سطر ۸ عدد صحیح که 0 یا 1 هستند با فاصله ورودی داده می‌شوند که وضعیت صندلی‌های واگن را نشان می‌دهند. 0 نشان دهنده خالی بودن صندلی و 1 نشان دهنده خالی نبودن است.\n\nخروجی\nدر تنها سطر خروجی، یک عدد که نشان دهنده تعداد جفت افراد چشم تو چشم است را خروجی دهید.",
        "output": "برای حل این مسئله، ما به سادگی وضعیت صندلی‌ها را در دو ردیف بررسی می‌کنیم و می‌شماریم که چند جفت صندلی مقابل هم هستند که هر دو پر هستند.\nدر هر ردیف، صندلی با شمارهi  روبروی صندلی با شماره i در ردیف مقابل قرار دارد. اگر هر دو صندلی پر باشند، یعنی دو نفر روبروی هم نشسته‌اند و \"چشم در چشم\" هستند.\nمراحل حل مسئله به صورت زیر است:\nورودی را در دو آرایه 8 تایی دریافت کنیم که هر کدام وضعیت نشستن افراد در یک ردیف را نشان می‌دهد.\nبرای هر جایگاهi، چک کنیم که آیا در هر دو ردیف در جایگاهi فرد نشسته است (یعنی هر دو عدد متناظر در آرایه‌ها 1 هستند).\nاگر هر دو 1 باشند، یک شمارنده را افزایش دهیم.\nدر نهایت، مقدار شمارنده که تعداد جفت‌های \"چشم در چشم\" را نشان می‌دهد را چاپ می‌کنیم."
    },
    {
        "instruction": "کد سوال زیر را بنویس و پیچیدگی زمانی آن را محاسبه کن.",
        "input": "از زمان‌های قدیم در ایران، سه سفر زیارتی هست که باعث می‌شود لقبی پشت اسم شما اضافه شود. سفر حج لقب «حاجی»، سفر کربلا لقب «کربلایی» و سفر مشهد لقب «مشتی» را به دنبال دارد. همچنین اگر یک نفر چند سفر را رفته باشد، اولویت لقب او به ترتیب با «حاجی»، «کربلایی» و «مشتی» است. حال به شما سفرهایی که یک نفر رفته است را به صورت یک رشته ۳ تایی از کاراکترهای Y و N می‌دهیم و از شما می‌خواهیم لقب درستی که باید نسبت دهیم را چاپ کنید. (اگر هیچ سفری نرفته بود به او «آقا» می‌گوییم.)\nورودی\nدر تنها سطر ورودی، یک رشته به طول ۳ از حروف Y (بله) و N (خیر) داده می‌شود که به‌ترتیب نشان‌دهنده‌ی تجربه‌ی سفر به «حج»، «کربلا» و «مشهد» است.\nخروجی\nدر صورتی که لقب «حاجی» است رشته‌ی Haji، «کربلایی» است رشته‌ی Karbalaee، «مشتی» است رشته‌ی Mashti و درصورتی که هیج کدام از این لقب‌ها را ندارد، Agha چاپ کنید.",
        "output": "input_str = input()  \nif input_str == \"YYY\":\n    print(\"Haji\")\nelif input_str == \"YNY\":\n    print(\"Karbalaee\")\nelif input_str == \"YYN\":\n    print(\"Mashti\")\nelse:\n    print(\"Agha\")\nدریافت ورودی: دریافت یک رشته به طول ۳، که در زمان ثابت انجام می‌شود (O(1)).\nانجام مقایسه‌ها و شرایط: در اینجا ۳ مقایسه انجام می‌شود تا وضعیت ورودی بررسی شود. این مقایسه‌ها نیز در زمان ثابت انجام می‌شوند (O(1)).\nچاپ لقب: یک عملیات چاپ انجام می‌شود که نیز در زمان ثابت انجام می‌شود (O(1)).\nبنابراین، کل پیچیدگی زمانی این کد O(1) است، یعنی زمان اجرای ثابت دارد و به تعداد ورودی وابسته نیست."
    },
    {
        "instruction": "انواع الگوریتم های مرتب سازی را نام ببر و با هم مقایسه کن.",
        "input": "",
        "output": "مرتب‌سازی حبابی (Bubble Sort):\nاین الگوریتم از ابتدا به انتها لیست را پیمایش کرده و همسایه‌های همسایه را مقایسه می‌کند.\nاگر عنصری از عناصر کوچکتر از عنصر بعدی باشد، آن‌ها را جابجا می‌کند.\nعملیات بالا تا زمانی که دیگر تغییری ایجاد نکند ادامه پیدا می‌کند.\nمرتب‌سازی انتخابی (Selection Sort):\nاین الگوریتم ابتدا عنصر کمترین مقدار را در لیست پیدا می‌کند و در ابتدای لیست قرار می‌دهد.\nسپس به جستجوی کمترین مقدار در بخش باقیمانده ادامه می‌دهد و آن را در جایگاه مناسب قرار می‌دهد.\nاین فرآیند تا زمانی که لیست کاملاً مرتب شود ادامه دارد.\nمرتب‌سازی درجی (Insertion Sort):\nاین الگوریتم عنصر به عنصر به لیست مرتب اضافه می‌کند.\nابتدا لیست خالی است و عنصر اول به عنوان عنصر مرتب قرار می‌گیرد.\nسپس هر عنصر جدید را به مکان مناسب در میان عناصر مرتب قبلی اضافه می‌کند.\nمرتب‌سازی ادغامی (Merge Sort):\nاین الگوریتم از روش تقسیم و حکومت استفاده می‌کند.\nلیست را به دو نیمه تقسیم می‌کند و سپس هر کدام از نیمه‌ها را به صورت جداگانه مرتب می‌کند.\nسپس دو نیمه مرتب را با هم ترکیب می‌کند تا لیست نهایی مرتب حاصل شود.\nمرتب‌سازی سریع (Quick Sort):\nاین الگوریتم نیز از تقسیم و حکومت استفاده می‌کند.\nیک عنصر پایه انتخاب می‌شود و لیست به دو بخش تقسیم می‌شود، یک بخش کوچکتر از عنصر پایه و یک بخش بزرگتر از آن.\nسپس هر دو بخش به صورت جداگانه مرتب می‌شوند و به یکدیگر می‌پیوندند.\nهمه این الگوریتم‌ها می‌توانند برای مرتب‌سازی لیست‌ها استفاده شوند، اما بهتر است الگوریتمی را انتخاب کرد که برای نیاز‌ها و محیط کاربردی خاص بیشتر متناسب باشد. برای مثال، اگر نیاز به مرتب‌سازی لیست‌های بزرگ هست، مرتب‌سازی ادغامی یا مرتب‌سازی سریع بهترین گزینه‌های ممکن هستند."
    },
    {
        "instruction": "روش های مختلف حل سوال زیر را بنویس و پیجیدگی زمانی هر یک را محاسبه کن.",
        "input": "برنامه ای بنویس که دو عدد a و b را گرفته و ب.م.م آن دو عدد را حساب کند.",
        "output": "الگوریتم اقتصادی اقلیدسی (یا الگوریتم اقلیدسی):\nاین الگوریتم با استفاده از تفاضل‌ها بین دو عدد، ب.م.م را محاسبه می‌کند.\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\nپیچیدگی زمانی این الگوریتم از نوع O(log(min(a, b))) است.\n\nاستفاده از کتابخانه‌های پایتون:\nدر پایتون، می‌توان از کتابخانه‌ی math استفاده کرد تا ب.م.م دو عدد را بدست آورد.\nimport math\n\ndef gcd(a, b):\n    return math.gcd(a, b)\nپیچیدگی زمانی این روش همچنان O(log(min(a, b))) است."
    },
    {
        "instruction": "برنامه ای بنویس که بتواند سوال زیر را در کوتاه ترین زمان ممکن حل کند.",
        "input": "برنامه ای بنویس که تعداد اعداد اول از ۱ تا n را محاسبه کند.",
        "output": "def is_prime(num):\n    if num <= 1:\n        return False\n    if num == 2:\n        return True\n    if num % 2 == 0:\n        return False\n    \n    for i in range(3, int(num**0.5) + 1, 2):\n        if num % i == 0:\n            return False\n    \n    return True\n\ndef count_primes_up_to_n(n):\n    count = 0\n    for i in range(1, n + 1):\n        if is_prime(i):\n            count += 1\n    return count\n\nn = int(input())\nresult = count_primes_up_to_n(n)\nprint(result)\n\nبرای محاسبه تعداد اعداد اول از 1 تا n، می‌توان از زبان برنامه‌نویسی Python استفاده کرد و از یک تابع به نام is_prime برای تشخیص اعداد اول استفاده کرد. سپس با استفاده از یک حلقه، اعداد از 1 تا n را بررسی کرد و تعداد اعداد اول را شمارش کرد. \nاین برنامه ابتدا یک تابع به نام is_prime را تعریف می‌کند که یک عدد را دریافت کرده و بررسی می‌کند که آیا اول است یا نه. سپس تابع count_primes_up_to_n تعداد اعداد اول از 1 تا n را محاسبه می‌کند و نتیجه را به کمک دستور print نمایش می‌دهد."
    },
    {
        "instruction": "برنامه ای بنویس که کمترین مقدار حافظه را استفاده کند و سوال زیر را حل کند.",
        "input": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\n\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\n\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\nReturn k.",
        "output": "def removeDuplicates(nums):\n    if len(nums) == 0:\n        return 0\n    \n    k = 1  \n    for i in range(1, len(nums)):\n        if nums[i] != nums[i - 1]:\n            nums[k] = nums[i]\n            k += 1\n    \n    return k\n# example\nnums = [1, 1, 2, 2, 2, 3, 4, 4, 5]\nresult = removeDuplicates(nums)\nprint(nums[:result])\nprint(result)"
    },
    {
        "instruction": "سوال زیر را به کمک hash map حل کن",
        "input": "برنامه ای بنویس که یک آرایه به عنوان به ورودی بگیرد و عددی که کمترین تکرار در این آرایه دارد را چاپ کند.",
        "output": "import java.util.HashMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] array = {1, 2, 3, 4, 2, 5, 1, 5, 6};\n        \n        HashMap<Integer, Integer> countMap = new HashMap<>();\n        \n        for (int num : array) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int minCount = Integer.MAX_VALUE;\n        int minNumber = -1;\n        \n        for (int num : array) {\n            int count = countMap.get(num);\n            if (count < minCount) {\n                minCount = count;\n                minNumber = num;\n            }\n        }\n        \n        System.out.println(minNumber);\n    }\n}"
    },
    {
        "instruction": "سوال زیر را به کمک لیست پیوندی حل کن.",
        "input": "برنامه ای بنویس که یک لیست پیوندی و یک عدد k را بگیرد و k عنصر آخر این لیست پیوندی را برگرداند.",
        "output": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n        else:\n            current = self.head\n            while current.next:\n                current = current.next\n            current.next = new_node\n\n    def get_kth_last_element(self, k):\n        if not self.head or k <= 0:\n            return None\n\n        slow_pointer = self.head\n        fast_pointer = self.head\n\n        for _ in range(k):\n            if not fast_pointer:\n                return None\n            fast_pointer = fast_pointer.next\n\n        while fast_pointer:\n            slow_pointer = slow_pointer.next\n            fast_pointer = fast_pointer.next\n\n        return slow_pointer.data\n\n# test\nif __name__ == \"__main__\":\n    linked_list = LinkedList()\n    linked_list.append(1)\n    linked_list.append(2)\n    linked_list.append(3)\n    linked_list.append(4)\n    linked_list.append(5)\n\n    k = 2\n    kth_last_element = linked_list.get_kth_last_element(k)\n    if kth_last_element is not None:\n        print(f\"{k}-th last element: {kth_last_element}\")\n    else:\n        print(f\"Invalid input or k is out of range\")"
    },
    {
        "instruction": "برای سوال زیر راه حلی ارائه بده که کمترین پیچیدگی زمانی را داشته باشد.",
        "input": "برنامه ای بنویس که یک آرایه ورودی بگیرد و تعداد component های ناهمبند گراف را مشخص کند.",
        "output": "def count_components(graph):\n    def dfs(node, visited):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited)\n\n    n = len(graph)\n    visited = [False] * n\n    components = 0\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, visited)\n            components += 1\n\n    return components\n\n# example:\ngraph = {\n    0: [1, 2],\n    1: [],\n    2: [3],\n    3: [],\n    4: [5],\n    5: []\n}\n\nresult = count_components(graph)\nprint(result)"
    },
    {
        "instruction": "یک راه حل هوشمندانه با پیچیدگی زمانی O(n) و پیچیدگی حافظه O(1) برای سوال زیر ارائه بده.",
        "input": "برنامه بنویس که آرایه ای نا مرتب با اعداد متمایز با سایز n-1 را ورودی بگیرد که تمام اعداد آن بین ۱ و n هستند و سپس عددی که بین ۱ و n باشد و در این آرایه وجود نداشته باشد را پیدا کند.",
        "output": "def find_missing_number(nums):\n    n = len(nums) + 1  \n    xor_result = 0\n\n    for i in range(1, n + 1):\n        xor_result ^= i\n\n    for num in nums:\n        xor_result ^= num\n\n    return xor_result\n\n# example\narr = [3, 7, 1, 2, 8, 4, 5]\nresult = find_missing_number(arr)\nprint(result)"
    },
    {
        "instruction": "تفاوت لیست پیوندی و لیست معمولی را بنویس و برای هر یک مزایا و معایبش را مشخص کن.",
        "input": "",
        "output": "لیست‌های معمولی (آرایه‌ها):\nتعریف:\nیک آرایه یک ساختمان داده خطی است که در آن عناصر در حافظه به صورت پشت سر هم ذخیره می‌شوند.\nمزایا:\nدسترسی سریع به عناصر: دسترسی به هر عنصر در آرایه با استفاده از اندیس آن به صورت O(1) است.\nسادگی کاربرد: کار با آرایه‌ها به دلیل سادگی ساختارشان آسان است.\nمعایب:\nاندازه ثابت: باید در هنگام ایجاد آرایه، اندازه آن را مشخص کرد و تغییر اندازه آن پیچیده و هزینه‌بر است.\nکارایی پایین در جابجایی عناصر: عملیات مانند حذف یا افزودن عناصر، به ویژه در ابتدا یا میانه آرایه، می‌تواند زمان‌بر باشد چرا که ممکن است نیاز به جابجایی تعداد زیادی از عناصر باشد.\nلیست‌های پیوندی (Linked Lists):\nتعریف:\nلیست پیوندی یک ساختار داده خطی است که در آن هر عنصر یک گره است و هر گره به گره بعدی پیوند دارد.\nمزایا:\nانعطاف‌پذیری در اندازه: لیست‌های پیوندی می‌توانند به راحتی بزرگ و کوچک شوند.\nکارایی بالا در عملیات افزودن و حذف: افزودن یا حذف یک عنصر در لیست پیوندی معمولاً سریع است، به شرطی که به گره مورد نظر دسترسی داشته باشیم.\nمعایب:\nدسترسی غیرمستقیم: برای دسترسی به یک عنصر خاص در لیست پیوندی، معمولاً باید از ابتدای لیست شروع کرد و تا رسیدن به آن عنصر پیش رفت، که این امر باعث می‌شود دسترسی به عناصر در زمان O(n) انجام شود.\nمصرف بیشتر حافظه: هر گره در لیست پیوندی به علاوه داده‌ای که نگهداری می‌کند، باید اطلاعات اضافی مربوط به پیوند (معمولاً یک یا دو اشاره‌گر) را نیز ذخیره کند."
    },
    {
        "instruction": "یک نمونه از پیاده سازی این ساختمان داده بنویس.",
        "input": "Max heap",
        "output": "class MaxHeap:\n    def __init__(self):\n        self.heap = []\n\n    def parent(self, i):\n        return (i - 1) // 2\n\n    def left_child(self, i):\n        return 2 * i + 1\n\n    def right_child(self, i):\n        return 2 * i + 2\n\n    def insert(self, value):\n        self.heap.append(value)\n        self.heapify_up(len(self.heap) - 1)\n\n    def heapify_up(self, i):\n        while i > 0 and self.heap[i] > self.heap[self.parent(i)]:\n            self.heap[i], self.heap[self.parent(i)] = self.heap[self.parent(i)], self.heap[i]\n            i = self.parent(i)\n\n    def extract_max(self):\n        if not self.heap:\n            return None\n        if len(self.heap) == 1:\n            return self.heap.pop()\n\n        root = self.heap[0]\n        self.heap[0] = self.heap.pop()\n        self.heapify_down(0)\n        return root\n\n    def heapify_down(self, i):\n        max_index = i\n        left = self.left_child(i)\n        right = self.right_child(i)\n\n        if left < len(self.heap) and self.heap[left] > self.heap[max_index]:\n            max_index = left\n        if right < len(self.heap) and self.heap[right] > self.heap[max_index]:\n            max_index = right\n\n        if i != max_index:\n            self.heap[i], self.heap[max_index] = self.heap[max_index], self.heap[i]\n            self.heapify_down(max_index)\n\n    def get_max(self):\n        if not self.heap:\n            return None\n        return self.heap[0]\n\n    def __str__(self):\n        return str(self.heap)\n\n# example\nmax_heap = MaxHeap()\nmax_heap.insert(5)\nmax_heap.insert(10)\nmax_heap.insert(2)\nmax_heap.insert(7)\n\nprint(\"Max Heap: \", max_heap)\nprint(\"Max Element: \", max_heap.extract_max())\nprint(\"Max Heap after extracting max: \", max_heap)"
    },
    {
        "instruction": "سوالی که در ادامه می آید را به کمک الگوریتم backtrack حل کن و پیچیدگی زمانی آن را محاسبه کن.",
        "input": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.",
        "output": "برای حل این مسئله با استفاده از الگوریتم Backtracking می‌توان به صورت بازگشتی تمامی ترتیب‌های ممکن برای اعداد در آرایه را ساخت. این الگوریتم به صورت بازگشتی عمل می‌کند و برای هر مرحله، یکی از اعداد را انتخاب کرده و به ترتیب تمامی اعداد دیگر را به عنوان اعداد بعدی ممکن انتخاب می‌کند تا ترتیب‌های ممکن را بسازد.\ndef permute(nums):\n    def backtrack(first):\n        if first == len(nums):\n            result.append(nums[:])\n        for i in range(first, len(nums)):\n            nums[first], nums[i] = nums[i], nums[first]\n            backtrack(first + 1)\n            nums[first], nums[i] = nums[i], nums[first]\n\n    result = []\n    backtrack(0)\n    return result\n\nدر این الگوریتم برای هر انتخاب از first تا len(nums) یک حلقه وجود دارد که اعمال backtracking را انجام می‌دهد. برای هر حلقه داخلی،یک حلقه دیگر وجود دارد که len(nums) - first بار اجرا می‌شود."
    },
    {
        "instruction": "سوال زیر را پاسخ دهید.",
        "input": "توضیح دهید که الگوریتم چیست.",
        "output": "الگوریتم یک مجموعه از دستورالعمل‌ها و مراحل مشخص است که برای حل یک مسئله خاص طراحی شده است. این دستورالعمل‌ها به ترتیب و با دقت توصیف شده‌اند تا به یک نتیجه یا حل مسئله مشخص برسد. الگوریتم‌ها در علوم کامپیوتر، ریاضیات و حوزه‌های مختلف دیگر به عنوان روش‌های محاسباتی و ترتیبی برای حل مسائل مورد استفاده قرار می‌گیرند."
    },
    {
        "instruction": "یک روش تقریبی برای مسئله رو به رو ارائه بده و میزان تقریب آن را محاسبه کن.",
        "input": "vertex cover",
        "output": "مسئله‌ی رو به رو (Vertex Cover) یک مسئله‌ی بهینه‌سازی در گراف است که هدف آن یافتن کمترین تعداد گره‌هایی است که هر یال در گراف حداقل به یکی از این گره‌ها متصل باشد. این مسئله به صورت رسمی به این صورت تعریف می‌شود: داده شده یک گراف G=(V,E)، یافتن مجموعه‌ای کمترین اندازه از گره‌ها به نام کاور گره (Vertex Cover) که برای هر یالی در گراف، حداقل یکی از دو سر این یال در کاور گره باشد.\nیکی از روش‌های تقریبی برای حل مسئله‌ی کاور گره این است که از الگوریتم تقریبی 2-تقریبی استفاده کنیم. این الگوریتم به این شکل عمل می‌کند:\nابتدا مجموعه‌ی خالی (C) را برای کاور گره ایجاد می‌کنیم.\nبرای هر یال در گراف، یکی از دو سر آن را به مجموعه C اضافه می‌کنیم. به این ترتیب، اگر C حاوی یک گره در یک یال باشد، آن یال به عنوان کاور شده در نظر می‌آید.\nالگوریتم به این ترتیب ادامه می‌دهد تا همه‌ی یال‌ها بررسی شوند.\nدر نهایت، مجموعه C کاور گره حاصل می‌شود.\nمیزان تقریب این الگوریتم برابر با 2 است، یعنی اندازه‌ی مجموعه‌ی C حداکثر دو برابر اندازه‌ی کاور گره بهینه خواهد بود. این الگوریتم تقریبی بسیار ساده است و به سرعت اجرا می‌شود، اما تضمین شده نیست که جواب بهینه را بدهد."
    },
    {
        "instruction": "به کمک روش prefix sum این مسئله را حل کن.",
        "input": "برنامه ای بنویس که ابتدا یک آرایه و عدد q را دریافت کند و سپس به q پرسش به این شکل پاسخ دهد:\nدر هر پرسش دو عدد a و b داده می شود و باید مجموع اعداد در بازه داده شده محاسبه و چاپ شود.",
        "output": "def calculate_prefix_sum(arr):\n    n = len(arr)\n    prefix_sum = [0] * n\n    prefix_sum[0] = arr[0]\n\n    for i in range(1, n):\n        prefix_sum[i] = prefix_sum[i-1] + arr[i]\n\n    return prefix_sum\n\ndef calculate_sum_in_range(prefix_sum, a, b):\n    if a == 0:\n        return prefix_sum[b]\n    else:\n        return prefix_sum[b] - prefix_sum[a-1]\n\nn = int(input())\narr = list(map(int, input().split()))\nq = int(input())\n\nprefix_sum = calculate_prefix_sum(arr)\n\nfor _ in range(q):\n    a, b = map(int, input().split())\n    result = calculate_sum_in_range(prefix_sum, a-1, b-1)\n    print(result)\n\n\nبرای حل این مسئله با استفاده از روش Prefix Sum می‌توان ابتدا یک آرایه از مقادیر اولیه ورودی ایجاد کرد که مقدار هر عنصر آن معادل جمع تمام عناصر از ابتدای آرایه تا عنصر مورد نظر در آرایه اصلی باشد. سپس برای هر پرسش، می‌توان اختلاف دو عدد از این آرایه پیدا کرده و مقدار مجموع در بازه مورد نظر را محاسبه کرد.\nاین کد ابتدا آرایه پیش‌پردازش را محاسبه می‌کند و سپس برای هر پرسش، مقدار مجموع در بازه مورد نظر را محاسبه و چاپ می‌کند."
    },
    {
        "instruction": "مسئله رو به رو را با کمترین پیچیدگی زمانی و بدون استفاده از stack حل کن.",
        "input": "برنامه ای بنویس که یک رشته از پرانتز ها را ورودی بگیرد و چک کند که آیا این پرانتز گذاری صحیح است یا نه.",
        "output": "def is_valid_parentheses(parentheses):\n    count = 0\n    \n    for char in parentheses:\n        if char == \"(\":\n            count += 1\n        elif char == \")\":\n            count -= 1\n            if count < 0:\n                return False\n    \n    return count == 0\n\n# example\nprint(is_valid_parentheses(\"()\"))         # True\nprint(is_valid_parentheses(\"(())\"))       # True\nprint(is_valid_parentheses(\"()()\"))       # True\nprint(is_valid_parentheses(\"(()())\"))     # True\nprint(is_valid_parentheses(\")(\"))         # False\nprint(is_valid_parentheses(\"())(\"))       # False\nprint(is_valid_parentheses(\"((()))))\"))   # False\n\nبرای حل این مسئله بدون استفاده از stack، می‌توان از یک متغیر ساده برای ذخیره تعداد پرانتز باز \"(\" و بسته \")\" استفاده کرد و هر بار که یک پرانتز باز می‌بینیم، مقدار متغیر افزایش یابد و هر بار که یک پرانتز بسته می‌بینیم، مقدار متغیر کاهش یابد. در انتها، اگر متغیر صفر باشد، پرانتز گذاری صحیح است و در غیر این صورت نادرست است."
    },
    {
        "instruction": "برای مسئله زیر از سایت Leetcode بهترین راه حل ممکن را ارائه بده.",
        "input": "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\n\nNote:\n\nA word is defined as a character sequence consisting of non-space characters only.\nEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\nThe input array words contains at least one word.",
        "output": "def fullJustify(words, maxWidth):\n    result, line, line_length = [], [], 0\n    \n    for word in words:\n        if line_length + len(word) + len(line) > maxWidth:\n            for i in range(maxWidth - line_length):\n                line[i % (len(line) - 1 or 1)] += ' '\n            result.append(''.join(line))\n            line, line_length = [], 0\n        \n        line.append(word)\n        line_length += len(word)\n    \n    result.append(' '.join(line).ljust(maxWidth))\n    \n    return result\n\nبرای حل این مسئله در Leetcode، می‌توان از یک رویکرد گرانه‌ای (greedy) استفاده کرد. به این ترتیب که به ترتیب کلمات را به خطوط اضافه کرد و تا وقتی که ممکن است بیشترین تعداد کلمات را در یک خط جا داد. سپس فاصله‌های اضافی بین کلمات را به صورت مساوی تا جای ممکن توزیع کرد. در صورتی که تعداد فاصله‌ها برابر نباشد، فاصله‌های اضافی به سمت چپ ترتیب داده می‌شوند.\nاین تابع fullJustify ورودی‌های words (لیست کلمات) و maxWidth (حداکثر عرض خط) را گرفته و خروجی را به صورت لیستی از خطوط متن تنظیم شده با عرض مشخص بر می‌گرداند."
    },
    {
        "instruction": "مسئله داده شده را به کمک الگوریتم حریصانه حل کن. آیا این الگوریتم همیشه بهترین جواب را بر می گرداند؟",
        "input": "knapsack",
        "output": "الگوریتم حریصانه (Greedy Algorithm) یکی از الگوریتم‌های ساده و موثر برای حل مسائل مسئله کوله‌پشتی (Knapsack Problem) است. در مسئله کوله‌پشتی، یک کوله با ظرفیت مشخص داریم و یک مجموعه از اشیاء با ارزش و وزن مشخص. هدف انتخاب یک زیرمجموعه از اشیاء به گونه‌ای است که مجموع ارزش اشیاء انتخاب شده بیشینه شود و مجموع وزن آن‌ها کمتر از ظرفیت کوله باشد.\nالگوریتم حریصانه در مسئله کوله‌پشتی به این صورت عمل می‌کند:\nمحاسبه نسبت ارزش به وزن برای هر شیء در مجموعه.\nمرتب کردن اشیاء بر اساس نسبت ارزش به وزن به ترتیب نزولی، به این معنی که اشیاء با نسبت ارزش به وزن بزرگتر در ابتدای لیست قرار می‌گیرند.\nاضافه کردن اشیاء به کوله به ترتیب مرتب شده تا زمانی که ظرفیت کوله پر شود یا تمام اشیاء انتخاب شوند.\nالگوریتم حریصانه معمولاً به سرعت یک پاسخ نزدیک به بهینه را پیدا می‌کند. با این حال، آنچه مهم است این است که این الگوریتم همیشه بهترین جواب را نمی‌یابد. ممکن است در برخی موارد، بهینه‌ترین جواب با انتخاب‌های مختلفی که الگوریتم حریصانه انجام می‌دهد، به دست آید.\nبه عنوان مثال، اگر اشیاء در مجموعه دارای ارزش‌های متفاوت و وزن‌های یکسان باشند، الگوریتم حریصانه ممکن است به اشیاء با ارزش بالاتر تمایل داشته باشد. اما اگر وزن‌ها نیز متفاوت باشند، ممکن است نتیجه الگوریتم حریصانه از بهینه‌ترین جواب فاصله داشته باشد.\nبه طور کلی، الگوریتم حریصانه معمولاً به عنوان یک الگوریتم تقریبی برای حل مسائل مسئله کوله‌پشتی استفاده می‌شود و نه الزاماً بهترین جواب را ارائه می‌دهد."
    },
    {
        "instruction": "مسئله ای که در ادامه می آید را به کمک دیکشنری در زبان پایتون حل کن.",
        "input": "یک آرایه از اعداد و عدد k داریم باید بررسی کنیم آیا زوجی از اعداد در این آرایه وجود دارد که جمعشان برابر k شود یا نه.",
        "output": "def has_pair_with_sum(arr, k):\n    num_dict = {} \n    for num in arr:\n        complement = k - num  \n        if complement in num_dict:  \n            return True  \n        num_dict[num] = True  \n    return False  \n\n# example\narr = [1, 2, 3, 4, 5]\nk = 9\nresult = has_pair_with_sum(arr, k)\nprint(k)"
    },
    {
        "instruction": "به کمک الگوریتم binary search سوال داده شده را حل کن و راه حل را به اختصار توضیح بده.",
        "input": "برنامه ای بنویس که یک آرایه مرتب شده و عدد k را به عنوان ورودی دریافت کند و اندیس اولین عدد k را چاپ کند.",
        "output": "def find_first_occurrence(arr, k):\n    left, right = 0, len(arr) - 1\n    result = -1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if arr[mid] == k:\n            result = mid\n            right = mid - 1  \n        elif arr[mid] < k:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result\n\n# inputs\narr = [1, 2, 2, 3, 3, 3, 4, 5, 5, 6]\nk = 3\n\nfirst_occurrence_index = find_first_occurrence(arr, k)\n\nif first_occurrence_index != -1:\n    print(first_occurrence_index)\nelse:\n    print(k)\n\n\nالگوریتم Binary Search یک الگوریتم مؤثر برای جستجو در یک آرایه مرتب است. برای حل این سوال، می‌توان از Binary Search استفاده کرد.\nاین برنامه از Binary Search برای جستجوی اندیس اولین تطابق عدد k در آرایه مرتب استفاده می‌کند. ابتدا بازه جستجو را بین اندیس 0 و اندیس آخر آرایه تعیین می‌کند. سپس در هر مرحله، اندیس وسط را محاسبه می‌کند و مقایسه می‌کند:\nاگر عدد میانی با عدد k برابر باشد، اندیس میانی به عنوان نتیجه ذخیره می‌شود و جستجو به سمت چپ ادامه می‌یابد تا اندیس اولین تطابق پیدا شود.\nاگر عدد میانی کمتر از عدد k باشد، جستجو به سمت راست ادامه می‌یابد.\nاگر عدد میانی بزرگتر از عدد k باشد، جستجو به سمت چپ ادامه می‌یابد.\nاین الگوریتم به سرعت اندیس اولین تطابق را در آرایه مرتب پیدا می‌کند و نتیجه را چاپ می‌کند."
    },
    {
        "instruction": "مسئله زیر با پیچیدگی زمانی O(logn) حل کن.",
        "input": "یک آرایه مرتب شده از اعداد و عدد k داده شده است. برنامه ای بنویس که نزدیک ترین عضو این آرایه به عدد k را چاپ کند.",
        "output": "def find_closest_element(arr, k):\n    low = 0\n    high = len(arr) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        if arr[mid] == k:\n            return arr[mid]\n        elif arr[mid] < k:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    if low == 0:\n        return arr[0]\n    elif high == len(arr) - 1:\n        return arr[-1]\n    else:\n        if abs(arr[low] - k) < abs(arr[high] - k):\n            return arr[low]\n        else:\n            return arr[high]\n\n# example:\narr = [1, 3, 5, 7, 9]\nk = 6\nresult = find_closest_element(arr, k)\nprint(result)\n\nاین کد از الگوریتم جستجوی دودویی برای پیدا کردن نزدیک‌ترین عدد به عدد k در آرایه مرتب شده استفاده می‌کند. الگوریتم به صورت بازگشتی کمترین و بزرگ‌ترین اعدادی را که از عدد k کوچک‌تر و بزرگ‌تر هستند، برای تعیین نزدیک‌ترین عدد به k پیدا می‌کند."
    },
    {
        "instruction": "تفاوت برنامه نویسی پویا و روش تقسیم و غلبه چیست؟",
        "input": "",
        "output": "برنامه‌نویسی پویا و روش تقسیم و غلبه (Divide and Conquer) دو روش متفاوت در طراحی و اجرای الگوریتم‌ها و برنامه‌نویسی هستند.\nبرنامه‌نویسی پویا (Dynamic Programming):\nمعمولاً برای حل مسائل بهینه‌سازی یا مسائل با تکرار زیاد به کار می‌رود.\nاز زیرساختارهای تکراری در مساله استفاده می‌کند تا محاسبات را کاهش دهد.\nاز جدولی برای ذخیره مقادیر محاسبه شده استفاده می‌کند تا جلوی محاسبه مجدد مقادیر را بگیرد (مموریزیشن).\nمعمولاً یک الگوریتم از پایین به بالا (Bottom-up) پیاده‌سازی می‌شود و نیازی به استفاده از بازگشتی ندارد.\nمعمولاً دارای پیچیدگی زمانی ثابت یا خطی است.\nروش تقسیم و غلبه (Divide and Conquer):\nمعمولاً برای حل مسائل تقسیم‌پذیر به کار می‌رود، به این معنا که مسئله اصلی به مسائل کوچکتر تقسیم می‌شود.\nبه شکل بازگشتی عمل می‌کند و معمولاً از تابع بازگشتی استفاده می‌کند.\nبرای حل مسئله اصلی، نتایج مسائل کوچکتر را ترکیب می‌کند (غلبه) تا به جواب نهایی برسد.\nمعمولاً برای اجرای بهینه‌تر الگوریتم‌های تقسیم و غلبه نیاز به بهینه‌سازی کارهای تقسیم و غلبه هست.\nپیچیدگی زمانی این روش معمولاً به صورت بازگشتی و با استفاده از حالت مستقیم یا موزون معرفی می‌شود و معمولاً به صورت مجردی به افزایش اندازه مسئله وابسته به میزان تقسیم‌پذیری مسئله است."
    },
    {
        "instruction": "الگوریتم داده شده را توضیح بده و آن را تحلیل کن.",
        "input": "Karger stein",
        "output": "الگوریتم Karger-Stein یک الگوریتم تصادفی برای حل مسائل جداسازی کوتاه‌ترین مسیرها (Minimum Cut) در گراف‌ها است. این مسئله به این صورت تعریف می‌شود: در یک گراف جهت‌دار وزن‌دار، می‌خواهیم دو دسته از گره‌ها پیدا کنیم که با حذف تعداد کمینه‌ای از یال‌ها، هیچ یالی از یک دسته به دیگری نرسد.\nالگوریتم Karger-Stein ترکیبی از دو الگوریتم دیگر به نام‌های Karger و Stein است. مراحل اصلی این الگوریتم به صورت زیر است:\nانتخاب تصادفی یک یال از گراف و حذف آن. این حذف باعث ایجاد دو قسمت جدا از گراف می‌شود.\nادغام دو گره متصل به دو طرف یال حذف شده به یک گره جدید. این گره جدید نمایندهٔ دو گره حذف شده است.\nتکرار مراحل 1 و 2 تا زمانی که گراف باقی‌مانده تنها دارای دو گره باشد.\nمحاسبه تعداد یال‌هایی که بین دو گره باقی‌مانده وجود دارد. این تعداد یال‌ها نمایندهٔ مقدار جداسازی کوتاه‌ترین مسیرها در گراف است.\nتحلیل الگوریتم Karger-Stein معمولاً به صورت احتمالی انجام می‌شود، زیرا الگوریتم از روش تصادفی استفاده می‌کند. تحلیل نشان داده‌است که این الگوریتم به احتمال زیادی جواب درست را پیدا می‌کند. دقیقاً نمی‌توان اطمینان داشت که جواب بهینه است، اما با تکرار زیاد الگوریتم، احتمال پیدا کردن جواب نزدیک بهینه به 1 نزدیک می‌شود.\nبه عبارت دیگر، الگوریتم Karger-Stein به صورت تصادفی کمینهٔ جداسازی مسیرها را با احتمال بالا حساب می‌کند. این الگوریتم در مقایسه با روش‌های دیگر معمولاً سریعتر است، اما به دلیل استفاده از تصادف در تحلیل، نمی‌توان به دقت اطمینان داشت که همیشه جواب بهینه را پیدا می‌کند."
    },
    {
        "instruction": "الگوریتمی بنویس که با روش تقریبی میانه را با پیچیدگی زمانی O(n) پیدا کند.",
        "input": "",
        "output": "import random\n\ndef partition(arr, low, high):\n    pivot_index = random.randint(low, high) \n    arr[pivot_index], arr[high] = arr[high], arr[pivot_index] \n    pivot = arr[high]\n    i = low\n    for j in range(low, high):\n        if arr[j] < pivot:\n            arr[i], arr[j] = arr[j], arr[i]\n            i += 1\n    arr[i], arr[high] = arr[high], arr[i]\n    return i\n\ndef quick_select(arr, low, high, k):\n    if low == high:\n        return arr[low]\n    \n    pivot_index = partition(arr, low, high)\n    if k == pivot_index:\n        return arr[k]\n    elif k < pivot_index:\n        return quick_select(arr, low, pivot_index - 1, k)\n    else:\n        return quick_select(arr, pivot_index + 1, high, k)\n\ndef find_median(arr):\n    n = len(arr)\n    if n % 2 == 1:\n        return quick_select(arr, 0, n - 1, n // 2)\n    else:\n        left_median = quick_select(arr, 0, n - 1, (n - 1) // 2)\n        right_median = quick_select(arr, 0, n - 1, n // 2)\n        return (left_median + right_median) / 2\n\n# example:\narr = [3, 1, 4, 2, 5]\nmedian = find_median(arr)\nprint(median)\n\nبرای پیدا کردن میانه با پیچیدگی زمانی O(n) با استفاده از یک الگوریتم تقریبی، می‌توان از الگوریتم QuickSelect استفاده کرد. این الگوریتم بر اساس الگوریتم QuickSort استوار است و به صورت بازگشتی عمل می‌کند. الگوریتم QuickSelect می‌تواند میانه را در زمانی خطی (O(n)) پیدا کند."
    },
    {
        "instruction": "مسئله هشت وزیر را به کمک الگوریتم زیر حل کن.",
        "input": "branch and bound",
        "output": "الگوریتم Branch and Bound یک روش معمول برای حل مسائل بهینه‌سازی است که می‌توان از آن برای حل مسئله هشت وزیر استفاده کرد. در این مسئله، هدف این است که هشت وزیر را در صفحه شطرنجی به گونه‌ای قرار دهیم که هیچکدام از آن‌ها یکدیگر را تهدید نکنند، یعنی در هیچ دو خانه‌ای قرار نگیرند که در یک خط افقی یا عمودی یا قطری باشند.\nابتدا یک صفحه شطرنجی 8x8 را تعریف می‌کنیم.\nیک تابع بازگشتی میسازیم که به ترتیب به ستون‌ها رفته و برای هر ستون، در تمام خانه‌های ممکن (ردیف‌ها) وضعیت وزیرها را بررسی می‌کند.\nدر هر مرحله، ابتدا برای ستون فعلی (مثلاً از ستون 1 تا 8)، یک وزیر را در یکی از خانه‌های ممکن قرار می‌دهیم و وضعیت تهدید را بررسی می‌کنیم.\nاگر وضعیت تهدیدی ایجاد نشده باشد (بدون تهدید)، به ستون بعدی می‌رود و این کار را تکرار می‌کنیم.\nاگر در یکی از مراحل تهدید ایجاد شود، از آن نقطه به پایان بر می‌گردیم و بررسی در ستون‌های قبلی را کنسل می‌کنیم.\nاگر به آخرین ستون برسیم و تمام وزیرها را در مکان‌های مناسب قرار داده باشیم (بدون تهدید)، یک حلقه بهینه پیدا کرده‌ایم.\nاگر تمام حالت‌ها بررسی شود و حلقه بهینه‌ای پیدا نشود، الگوریتم به بازگشت می‌پردازد و به گام‌های قبلی برمی‌گردد تا تلاش کند حلقه‌های دیگری پیدا کند.\nاین الگوریتم بهینه‌سازی برای حل مسئله هشت وزیر به کمک استفاده از شرایط Branch and Bound می‌تواند به جواب مناسبی برسد. با ادامه تجزیه و تحلیل مراحل الگوریتم و بهینه‌سازی آن، ممکن است به جواب نهایی برسید."
    },
    {
        "instruction": "روش حل سوال زیر را توضیح بده و سپس کد آن را بنویس. در نهایت آن را از نظر پیچیدگی زمانی تحلیل کن.",
        "input": "برنامه ای بنویس که یک لیست تو در تو را گرفته و یک لیست flat را برگرداند. به عنوان مثال اگر ورودی برای [1,[2,3], 4] باشد آنگاه خروجی باید برابر [1,2,3,4] باشد.",
        "output": "def flatten_list(input_list):\n    if not input_list:\n        return []\n\n    output_list = []\n\n    for element in input_list:\n        if isinstance(element, (int, float)):\n            output_list.append(element)\n        elif isinstance(element, list):\n            output_list.extend(flatten_list(element))\n\n    return output_list\n\nبرای حل این سوال، می‌توان از یک تابع بازگشتی استفاده کرد که لیست تو در تو را باز کند و عناصر آن را به یک لیست flat اضافه کند.\n\nتعریف یک تابع بازگشتی به نام flatten_list که یک ورودی به نام input_list (لیست تو در تو) دارد.\nاگر input_list خالی باشد، لیست خروجی خالی را برمیگردانیم.\nدر غیر این صورت، برای هر عنصر element در input_list:\nاگر element یک عدد باشد (یعنی عدد صحیح یا اعشاری)، آن را به لیست خروجی اضافه می کنیم.\nاگر element یک لیست باشد، تابع flatten_list را با ورودی element فراخوانی می کنیم تا لیست داخلی را flat کنیم.\nدر نهایت، لیست خروجی را برمیگردانیم.\nاین کد از یک حلقه for برای ترavers کردن عناصر لیست استفاده می‌کند.\nدر هر مرحله، اگر عنصر یک لیست باشد، تابع flatten_list را با آن فراخوانی می‌کنیم.\nتعداد مراحل این حلقه برابر با تعداد کل عناصر در لیست ورودی می‌باشد.\nبنابراین، پیچیدگی زمانی این کد در بدترین حالت برابر با O(n) می‌باشد، که در آن n تعداد کل عناصر در لیست ورودی است."
    },
    {
        "instruction": "سوال زیر را با پیچیدگی زمانی O(n) و پیچیدگی حافظه O(1) حل کن و کد آن را بنویس.",
        "input": "به چند روش می توان یک مستطیل 2 در n را با n کاشی 2 در ۱پوشش داد.",
        "output": "def coverRectangle(n):\n    if n % 2 != 0:\n        return 0  \n    return n // 2\n\nn = int(input())\nresult = coverRectangle(n)\nprint(n, result)\n\nاین کد تعداد مستطیل‌های 2 در n که با n کاشی 2 در 1 پوشش داده می‌شوند را محاسبه می‌کند. اگر تعداد کاشی‌ها فرد باشد، نمی‌توانیم مستطیل 2 در n را به کامل پوشش دهیم، بنابراین نتیجه 0 خواهد بود. در غیر این صورت، تعداد مستطیل‌ها برابر با n // 2 خواهد بود."
    },
    {
        "instruction": "الگوریتم جست و جوی دودویی چگونه کار می کند؟",
        "input": "",
        "output": "الگوریتم جست و جوی دودویی یک الگوریتم جستجوی کارآمد برای یافتن یک عنصر خاص در یک لیست یا آرایه مرتب است. این الگوریتم به سرعت به عنصر مورد نظر پیش می‌رود و تعداد مقایسات مورد نیاز برای یافتن عنصر را به حداقل می‌رساند. این الگوریتم به شرح زیر عمل می‌کند:\nمرحله اول: تعیین محدوده‌ی جستجو\nدر ابتدا، محدوده‌ی جستجو به تمام لیست یا آرایه تعیین می‌شود. بنابراین، شروع محدوده‌ی جستجو از ابتدای لیست (اولین عنصر) و پایان محدوده‌ی جستجو از انتهای لیست (آخرین عنصر) است.\nمرحله دوم: محاسبه میانه\nمیانه (وسط) محدوده‌ی جستجو محاسبه می‌شود. برای این منظور، ابتدا شماره عنصر وسط محدوده‌ی جستجو برابر با (شماره‌ی ابتدا + شماره‌ی پایان) / 2 محاسبه می‌شود.\nمرحله سوم: مقایسه\nمقدار میانه با مقدار مورد نظر مقایسه می‌شود.\nاگر میانه برابر با مقدار مورد نظر باشد، الگوریتم پایان می‌یابد و عنصر مورد نظر یافت شده است.\nاگر میانه کوچکتر از مقدار مورد نظر باشد، محدوده‌ی جستجو به نصف دوم بالایی تغییر می‌یابد و الگوریتم به مرحله 2 برمی‌گردد.\nاگر میانه بزرگتر از مقدار مورد نظر باشد، محدوده‌ی جستجو به نصف دوم پایینی تغییر می‌یابد و الگوریتم به مرحله 2 برمی‌گردد.\nمرحله چهارم: تکرار\nمراحل 2 و 3 تا زمانی که محدوده‌ی جستجو به یک عنصر واحد (شماره‌ی ابتدا و پایان یکی شوند) کاهش یابد و عنصر مورد نظر یافت نشود، تکرار می‌شوند.\nاین الگوریتم به شکل بهینه‌تری عمل می‌کند تا الگوریتم جستجوی خطی و در صورتی که لیست یا آرایه مرتب باشد، به سرعت به عنصر مورد نظر برسد. تعداد مقایسات مورد نیاز برای یافتن عنصر در الگوریتم جست و جوی دودویی به صورت لگاریتمی با افزایش اندازه لیست یا آرایه کاهش می‌یابد، که این باعث می‌شود که الگوریتم بسیار کارآمد باشد."
    },
    {
        "instruction": "یک روش ۲ تقریب برای مسئله داده شده ارائه بده و کد آن را بنویس.",
        "input": "مسئله TSP در حالتی که نامساوی مثلثی برقرار باشد.",
        "output": "import numpy as np\n\ndef nearest_neighbor_tsp(distance_matrix):\n    num_cities = len(distance_matrix)\n    tour = [0]  \n    unvisited_cities = set(range(1, num_cities))\n\n    while unvisited_cities:\n        current_city = tour[-1]\n        nearest_city = min(unvisited_cities, key=lambda city: distance_matrix[current_city][city])\n        tour.append(nearest_city)\n        unvisited_cities.remove(nearest_city)\n\n    tour.append(tour[0])\n\n    return tour\n\n# example:\ndistance_matrix = np.array([\n    [0, 29, 20, 21],\n    [29, 0, 15, 17],\n    [20, 15, 0, 28],\n    [21, 17, 28, 0]\n])\n\ntour = nearest_neighbor_tsp(distance_matrix)\nprint(tour)\n\nدر مسئله مسیرهای کوتاه‌ترین گردشگر (TSP) با فرض نامساوی مثلثی، یکی از روش‌های تقریبی معروف استفاده از الگوریتم نزدیک‌ترین همسایه (Nearest Neighbor Algorithm) است. الگوریتم نزدیک‌ترین همسایه به این شکل کار می‌کند که از یک نقطه شروع می‌کند و به ترتیب به نزدیک‌ترین نقطه‌ای می‌رود که هنوز در مسیر نگرفته‌شده باشد، و به همین ترتیب ادامه می‌دهد تا همه نقاط را در مسیر خود قرار دهد.\nاین کد برای مسئله TSP با نامساوی مثلثی از الگوریتم نزدیک‌ترین همسایه استفاده می‌کند تا مسیر کوتاه‌ترین گردشگر را بیابد و انتهای مسیر به شهر اول بازگردانده شود.این الگوریتم یک راه حل تقریبی است و ممکن است نتیجه بهینه‌ای نداشته باشد، اما به سرعت مسئله را حل می‌کند."
    },
    {
        "instruction": "برای حل سوال زیر از چه الگوریتمی می تتوان استفاده کرد. این الگوریتم را توضیح بده و کد آن را بنویس.",
        "input": "پر کردن یک جدول سودوکو",
        "output": "def is_valid(board, row, col, num):\n\n    if num in board[row]:\n        return False\n\n    if num in [board[i][col] for i in range(9)]:\n        return False\n\n    start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n    for i in range(start_row, start_row + 3):\n        for j in range(start_col, start_col + 3):\n            if board[i][j] == num:\n                return False\n\n    return True\n\ndef solve_sudoku(board):\n    empty = find_empty_location(board)\n    if not empty:\n        return True  \n\n    row, col = empty\n\n    for num in range(1, 10):\n        if is_valid(board, row, col, num):\n            board[row][col] = num\n\n            if solve_sudoku(board):\n                return True\n\n            board[row][col] = 0 \n\n    return False\n\ndef find_empty_location(board):\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == 0:\n                return (i, j)\n    return None\n\ndef print_board(board):\n    for row in board:\n        print(\" \".join(str(num) for num in row))\n\n# example:\nsudoku_board = [\n    [5, 3, 0, 0, 7, 0, 0, 0, 0],\n    [6, 0, 0, 1, 9, 5, 0, 0, 0],\n    [0, 9, 8, 0, 0, 0, 0, 6, 0],\n    [8, 0, 0, 0, 6, 0, 0, 0, 3],\n    [4, 0, 0, 8, 0, 3, 0, 0, 1],\n    [7, 0, 0, 0, 2, 0, 0, 0, 6],\n    [0, 6, 0, 0, 0, 0, 2, 8, 0],\n    [0, 0, 0, 4, 1, 9, 0, 0, 5],\n    [0, 0, 0, 0, 8, 0, 0, 7, 9]\n]\n\nif solve_sudoku(sudoku_board):\n    print_board(sudoku_board)\nelse:\n    print(\"No solution exists\")\n\n\nبرای حل جدول سودوکو، می‌توان از الگوریتم \"بازگشت به عقب\" (Backtracking) استفاده کرد. این الگوریتم یک رویکرد مرسوم در حل مسائل بازیابی است که سعی می‌کند تمام حالات ممکن را برای یافتن راه‌حل امتحان کند. در مورد سودوکو، این به معنای پر کردن جدول با اعداد، با رعایت قوانین سودوکو (هر ردیف، ستون و بلوک ۳x۳ باید شامل اعداد ۱ تا ۹ باشد بدون تکرار) و بازگشت و تغییر اعداد در صورت لزوم است."
    },
    {
        "instruction": "به کمک روش جمع پیشوندی روشی را برای سوال زیر ارائه بده.",
        "input": "یک آرایه دو بعدی از اعداد داده شده است. می خواهیم بزرگترین زیرمستطیل عضو این آرایه از نظر جمع اعداد درون آن پیدا کنیم.",
        "output": "برای حل این مسئله با استفاده از روش جمع پیشوندی (Prefix Sum)، می‌توانید مراحل زیر را دنبال کنیم:\nابتدا یک آرایه دو بعدی برای محاسبه جمع پیشوندی میسازیم. این آرایه باید ابعادی مشابه با آرایه اصلی داشته باشد.\nمقادیر اولیه آرایه جمع پیشوندی را محاسبه میکنیم. برای این منظور، مقدار اول در هر سطر و ستون برابر با مقدار معادل در آرایه اصلی خواهد بود.\nسپس به ترتیب از چپ به راست و از بالا به پایین، برای هر خانه (i، j) در آرایه جمع پیشوندی، جمع مقادیر خانه‌های قبلی (با توجه به جهت حرکت) را با خود مقدار آن خانه جمع میکنیم. این کار باعث می‌شود که هر خانه در آرایه جمع پیشوندی مقدار جمع تمام عناصر در زیرماتریکس مستطیلی با بالا و چپ‌ترین خانه (1،1) خودش را نگه دارد.\nحالا به ترتیب برای هر مستطیل ممکن در آرایه اصلی (با ترکیبی از دو خانه برای نقاط گوشه‌ای)، با استفاده از مقادیر مختصات گوشه‌ها در آرایه جمع پیشوندی، جمع عناصر درون مستطیل را محاسبه میکنیم و مقایسه میکنیم تا بزرگترین مستطیل را پیدا کنیم.\nبا اجرای این الگوریتم،می‌توان بزرگترین زیرمستطیل در آرایه دو بعدی را با توجه به جمع اعداد درون آن پیدا کنیم."
    },
    {
        "instruction": "به کمک برنامه نویسی بازگشتی مسئله زیر را حل کن.",
        "input": "یک آرایه از اعداد داریم. می خواهیم مجموعه شامل جمع عناصز تمام زیر مجموعه های این آرایه را پیدا کنیم.",
        "output": "def find_subsets(arr):\n    def backtrack(subset, index):\n        if index == len(arr):\n            subsets.append(subset)\n            return\n        backtrack(subset + [arr[index]], index + 1)\n        backtrack(subset, index + 1)\n\n    subsets = []\n    backtrack([], 0)\n    return subsets\n\n# example:\narray = [1, 2, 3]\nresult = find_subsets(array)\nprint(result)"
    },
    {
        "instruction": "سوال الگوریتمی زیر را در نظر بگیر. برای این سوال روشی حریصانه ارائه بده که آن را در O(n) حل کند.",
        "input": "یک آرایه از اعداد داریم که هر بار می توانیم این عملیات را بر روی آن اجرا کنیم: یک دنباله از اعداد این آرایه را بگیریم و مقدار آن را به اندازه  x افزایش دهیم. می خواهیم با حداقل تکرار این عملیات به آرایه ای برسیم که به شکل غیرنزولی در آمده باشد.",
        "output": "import math\n\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\nif x == 0:\n    failed = False\n    for i in range(1, n):\n        if a[i] < a[i - 1]:\n            print(-1)\n            failed = True\n            break\n    else:\n        print(0)\nelse:\n    if x < 0:\n        x = -x\n        a = list(reversed(a))\n        for i in range(n):\n            a[i] = -a[i]\n\n    res = 0\n    for i in range(1, n):\n        a[i] += res * x\n\n        if a[i] >= a[i - 1]:\n            continue\n\n        tmp = math.ceil((a[i - 1] - a[i]) / x)\n        a[i] += tmp * x\n        res += tmp\n\n    print(res)\n\nدر این کد، ابتدا ورودی‌ها به تعداد عناصر آرایه و مقدار x خوانده می‌شوند.\nسپس آرایه a از ورودی خوانده می‌شود.\nاگر مقدار x برابر با صفر باشد، کد بررسی می‌کند که آیا آرایه از پیش غیرنزولی است یا نه. اگر آرایه نزولی نباشد، 0 چاپ می‌شود و در غیر این صورت -1 چاپ می‌شود.\nاگر x کمتر از صفر باشد، مقدار آن را مثبت می‌کنیم و عناصر آرایه a را با انعکاس دادن و عملیات منفی کردن مقادیرش آماده می‌کنیم.\nسپس با استفاده از حلقه for برای هر عنصر غیر اول آرایه، مقدار آن عنصر را با res ضرب در x افزایش می‌دهیم.\nاگر مقدار عنصر فعلی بزرگتر یا مساوی عنصر قبلی باشد، ادامه می‌دهیم.\nدر غیر این صورت، تعداد حرکات مورد نیاز برای افزایش عنصر فعلی به حداقل مقداری که بزرگتر یا مساوی عنصر قبلی شود، با استفاده از تقسیم و گرد کردن به بالا محاسبه می‌شود و به res اضافه می‌شود.\nدر نهایت، تعداد حرکات مورد نیاز چاپ می‌شود."
    },
    {
        "instruction": "الگوریتم زیر را توضیح بده و آن را از نظر زمانی و حافظه تحلیل کن و مشخص کن در چه صورتی به درستی کار می کند؟",
        "input": "Spaghetti sort",
        "output": "Spaghetti Sort یک الگوریتم مرتب‌سازی متفاوت و غیرمعمول است که برای مرتب‌سازی اعداد از طریق ترتیب ظاهری آن‌ها بر روی یک سطح صاف، مانند میز، استفاده می‌شود.\nاعداد مورد نظر را به شکلی تصادفی بر روی میز قرار می‌دهیم.\nسپس از سمت چپ به راست یک انگشتر را بر روی اعداد قرار می‌دهیم و اعداد را با ترتیب ظاهری خودشان مرتب می‌کنیم. انگشتر را به اندازه‌ای حرکت می‌دهیم که بتوانیم اعداد را با دقت مورد نظر خود مرتب کنیم.\nپس از اینکه به انتهای میز رسیدیم و اعداد را مرتب کردیم، مرحله اول به اتمام رسیده و ممکن است اعداد همچنان به ترتیب نهایی نباشند.\nحالا باید انگشتر را از انتهای میز به ابتدای آن بیاوریم و دوباره با ترتیب ظاهری اعداد را مرتب کنیم.\nاین عملیات تا زمانی ادامه دارد که اعداد به ترتیب نهایی برسند. در هر مرحله، اگر برخورد به یکی از اعداد باعث تغییر مکان آن شود، مرحله به اتمام نرسیده و باید دوباره شروع شود.\nتحلیل زمانی و حافظه Spaghetti Sort بسیار پیچیده و مستلزم مشاهده و تجربه عملی در مورد مقدار اعداد و تعداد اعداد است. این الگوریتم از لحاظ عملی بسیار نامناسب و کارآمدی ندارد و تقریباً هیچ کاربرد عملی ندارد.\nزمان اجرای الگوریتم Spaghetti Sort به شدت وابسته به ترتیب اولیه اعداد و تعداد اعداد است. در بدترین حالت ممکن، ممکن است زمان اجرا به صورت مربعی یا بیشتر باشد. همچنین، این الگوریتم برای تعداد زیادی اعداد یا اعداد با مقادیر بزرگ بسیار نامناسب است و به دلیل متغیر بودن تعداد مراحل و حرکات انگشتر، حافظه زیادی مصرف می‌کند.\nبه طور کلی، Spaghetti Sort یک الگوریتم تفریحی و غیرعملی است و در عمل معمولاً از الگوریتم‌های مرتب‌سازی متداول‌تری مانند Bubble Sort، Quick Sort، Merge Sort یا Heap Sort استفاده می‌شود که به طور معمول با تحلیل زمانی و حافظه بهتری اجرا می‌شوند."
    },
    {
        "instruction": "برنامه ای بهینه بنویس که مثلث خیام را چاپ کند.",
        "input": "",
        "output": "def print_pascal_triangle(n):\n    for i in range(1, n+1):\n        for j in range(0, n-i+1):\n            print(\" \", end=\"\")\n        \n        num = 1\n        for j in range(1, i+1):\n            print(num, \" \", end=\"\")\n            num = num * (i - j) // j\n        \n        print()\n\n# example:\nn = 5\nprint_pascal_triangle(n)"
    },
    {
        "instruction": "برای سوال زیر یک روش بهینه و به زبان c ارائه بده.",
        "input": "برنامه ای بنویس که دو رشته را به عنوان ورودی دریافت کند و اولین جایی که رشته اول در رشته دوم آمده است را پیدا کند.",
        "output": "#include <stdio.h>\n#include <string.h>\n\nint findSubstring(char *pattern, char *text) {\n    int patternLen = strlen(pattern);\n    int textLen = strlen(text);\n\n    if (patternLen > textLen) {\n        return -1;\n    }\n\n    for (int i = 0; i <= textLen - patternLen; i++) {\n        int j;\n\n        for (j = 0; j < patternLen; j++) {\n            if (text[i + j] != pattern[j]) {\n                break;\n            }\n        }\n\n        if (j == patternLen) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    char text[100], pattern[100];\n\n    printf(\"Enter the main text: \");\n    gets(text);\n    printf(\"Enter the pattern to find: \");\n    gets(pattern);\n\n    int position = findSubstring(pattern, text);\n\n    if (position != -1) {\n        printf(\"Pattern found at position: %d\\n\", position);\n    } else {\n        printf(\"Pattern not found in the text\\n\");\n    }\n\n    return 0;\n}"
    },
    {
        "instruction": "ساختمان داده set و عملیات رو آن ها را توضیح بده و تحلیل کن.",
        "input": "",
        "output": "ساختمان داده‌ی Set یا مجموعه یک مجموعه‌ی مشخص از داده‌هاست که هر عنصر در آن منحصر به فرد است و ترتیب خاصی ندارد. در برنامه‌نویسی و علم کامپیوتر، این ساختمان داده برای نگهداری مجموعه‌ای از داده‌ها که تکرار در آن‌ها معنی ندارد، استفاده می‌شود. Setها در زبان‌های برنامه‌نویسی مختلفی مانند Python, Java, C++, و... پیاده‌سازی شده‌اند.\nعملیات‌های اصلی روی Set:\nافزودن (Add): می‌توان یک عنصر جدید به مجموعه اضافه کرد. اگر عنصر از قبل وجود داشته باشد، مجموعه تغییری نخواهد کرد.\nحذف کردن (Remove): می‌توان یک عنصر را از مجموعه حذف کرد. اگر عنصر در مجموعه نباشد، بسته به پیاده‌سازی، ممکن است خطا رخ دهد یا اتفاقی نیفتد.\nعضویت (Membership): می‌توان بررسی کرد که آیا یک عنصر خاص در مجموعه وجود دارد یا خیر.\nتعداد عناصر (Size/Cardinality): می‌توان تعداد کل عناصر موجود در مجموعه را دریافت کرد.\nتست خالی بودن (Empty): می‌توان بررسی کرد که مجموعه خالی است یا خیر.\nعملیات‌های ریاضی روی Set:\nاتحاد (Union): اتحاد دو مجموعه شامل همه عناصری است که حداقل در یکی از دو مجموعه وجود دارند.\nتقاطع (Intersection): تقاطع دو مجموعه شامل عناصری است که در هر دو مجموعه وجود دارند.\nتفاضل (Difference): تفاضل دو مجموعه A و B شامل عناصری است که در A هستند اما در B نیستند.\nتفاضل متقارن (Symmetric Difference): عناصری که فقط در یکی از دو مجموعه وجود دارند.\nتحلیل:\nپیچیدگی زمانی: عملیات‌های Set معمولاً سریع هستند. برای مثال، در بسیاری از پیاده‌سازی‌ها، عملیات‌های افزودن، حذف و عضویت در O(1) (زمان ثابت) انجام می‌شوند، به شرطی که توزیع عناصر مناسب باشد.\nکاربردها: Setها در مواردی کاربرد دارند که نیاز به نگهداری مجموعه‌ای از عناصر بدون تکرار است، مانند نگهداری لیستی از کاربران یکتا در یک برنامه وب، یا برای انجام عملیات‌های ریاضی مجموعه‌ای.\nمحدودیت‌ها: ترتیب عناصر در یک Set معمولاً مهم نیست و نمی‌توان روی آن‌ها حساب کرد. همچنین، در برخی پیاده‌سازی‌ها، عناصر باید قابلیت مقایسه (برای مثال، برای تست عضویت یا ترتیب) داشته باشند.\nدر کل، Set یک ساختمان داده‌ی قدرتمند و کارآمد است که در بسیاری از مسائل برنامه‌نویسی برای مدیریت مجموعه‌هایی از داده‌ها به کار می‌رود."
    }
]
